// dex/dex.js - Logic for the Interactive Pokedex Viewer

document.addEventListener('DOMContentLoaded', () => {
    // --- Constants ---
    const TCG_API_KEY = 'a65acbfc-55e5-4d2c-9278-253872a1bc5a'; // <<< --- PUT YOUR POKEMON TCG API KEY HERE --- >>> Get yours from https://dev.pokemontcg.io/
    const MAX_MOVES_DISPLAY = 50; // Moves per page
    const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';
    const GENERATION_RANGES = {
        1: { limit: 151, offset: 0 }, 2: { limit: 100, offset: 151 }, 3: { limit: 135, offset: 251 },
        4: { limit: 107, offset: 386 }, 5: { limit: 156, offset: 493 }, 6: { limit: 72, offset: 649 },
        7: { limit: 88, offset: 721 }, 8: { limit: 96, offset: 809 }, 9: { limit: 120, offset: 905 },
        all: { limit: 1500, offset: 0 } // Fetch a large limit for 'all'
    };
    const POKEMON_TYPES = [ 'normal', 'fire', 'water', 'electric', 'grass', 'ice', 'fighting', 'poison', 'ground', 'flying', 'psychic', 'bug', 'rock', 'ghost', 'dragon', 'dark', 'steel', 'fairy' ];

    // --- State Variables ---
    let currentPokemonData = null; let currentSpeciesData = null; let currentFlavorTextEntries = [];
    let currentStats = []; let currentMoves = []; let currentTcgCards = []; let filteredTcgCards = [];
    let isShiny = false; let isFemale = false;
    let currentStatSort = 'default'; let activeSubTab = 'summary-content';
    let currentGeneration = 1; let currentTypeFilter = 'all';
    let fullPokemonListCache = {}; let detailedPokemonCache = {}; let typeDataCache = {};
    let allPokemonSpeciesList = null;
    let currentVarieties = [];
    let currentMovesPage = 1;
    const movesPerPage = MAX_MOVES_DISPLAY;

    // --- DOM Elements ---
    const initialLoadingOverlay = document.getElementById('initial-loading-overlay');
    const appContainer = document.getElementById('app-container');
    const dexGridView = document.getElementById('dex-grid-view');
    const detailViewLightbox = document.getElementById('detail-view-lightbox');
    const detailCloseButton = document.getElementById('detail-close-button');
    const generationTabsContainer = document.getElementById('generation-tabs');
    const typeFilterButtonsContainer = document.getElementById('type-filter-buttons');
    const mainSearchInput = document.getElementById('pokemon-search-main');
    const mainSearchButton = document.getElementById('search-button-main');
    const pokedexGrid = document.getElementById('pokedex-grid');
    const dexGridLoader = document.getElementById('dex-grid-loader');
    // Detail View Elements
    const detailLoader = document.getElementById('detail-loader');
    const detailErrorMessageDiv = document.getElementById('detail-error-message');
    const detailErrorText = document.getElementById('detail-error-text');
    const detailPokemonInfoDiv = document.getElementById('pokemon-info');
    const detailContentSection = document.getElementById('content-section');
    const detailVisualSection = document.getElementById('visual-section');
    const detailPokemonNameDisplay = document.getElementById('pokemon-name-display');
    const detailPokemonIdSpan = document.getElementById('pokemon-id');
    const detailVariantSelectorContainer = document.getElementById('variant-selector-container');
    const detailVariantSelect = document.getElementById('variant-select');
    const detailGameVersionSelect = document.getElementById('game-version-select');
    const detailPokemonDescriptionP = document.getElementById('pokemon-description');
    const detailPokemonHeightP = document.getElementById('pokemon-height');
    const detailPokemonWeightP = document.getElementById('pokemon-weight');
    const detailVariantInfoSection = document.getElementById('variant-info-section');
    const detailStatSortButtonsContainer = document.getElementById('stat-sort-buttons');
    const detailStatsContainer = document.getElementById('stats-container');
    const detailAbilitiesList = document.getElementById('abilities-list');
    const detailMovesList = document.getElementById('moves-list');
    const detailMovesPagination = document.getElementById('moves-pagination');
    const detailPrevMovePageButton = document.getElementById('prev-move-page');
    const detailNextMovePageButton = document.getElementById('next-move-page');
    const detailMovePageInfo = document.getElementById('move-page-info');
    const detailPokemonImage = document.getElementById('pokemon-image');
    const detailPokemonImageContainer = document.getElementById('pokemon-image-container');
    const detailShinyToggleButton = document.getElementById('shiny-toggle');
    const detailGenderToggleButton = document.getElementById('gender-toggle');
    const detailPokemonTypesDiv = document.getElementById('pokemon-types');
    const detailMainTabsContainer = document.getElementById('tabs');
    const detailMainTabButtons = detailMainTabsContainer.querySelectorAll('.tab-button');
    const detailMainTabContents = detailContentSection.querySelectorAll('.tab-content');
    const detailGameInfoTabContainer = document.getElementById('game-info-tab');
    const detailGameInfoTabsContainer = document.getElementById('game-info-tabs');
    const detailSubTabButtons = detailGameInfoTabsContainer.querySelectorAll('.sub-tab-button');
    const detailSubTabContents = detailGameInfoTabContainer.querySelectorAll('.sub-tab-content');
    const detailTcgSearchInput = document.getElementById('tcg-search');
    const detailTcgSearchButton = document.getElementById('tcg-search-button');
    const detailTcgLoader = document.getElementById('tcg-loader');
    const detailTcgErrorDiv = document.getElementById('tcg-error');
    const detailTcgErrorText = document.getElementById('tcg-error-text');
    const detailTcgCardsContainer = document.getElementById('tcg-cards-container');
    // TCG Lightbox Elements
    const tcgLightbox = document.getElementById('tcg-lightbox');
    const lightboxCloseButton = document.getElementById('lightbox-close');
    const lightboxCardName = document.getElementById('lightbox-card-name');
    const lightboxCardImage = document.getElementById('lightbox-card-image');
    const lightboxCardDetails = document.getElementById('lightbox-card-details');

    // --- Stat Name Mapping & Helpers ---
    const statNameMapping = { 'hp': 'HP', 'attack': 'Attack', 'defense': 'Defense', 'special-attack': 'Sp. Atk', 'special-defense': 'Sp. Def', 'speed': 'Speed' };
    const defaultStatOrder = ['hp', 'attack', 'defense', 'special-attack', 'special-defense', 'speed'];
    const cleanFlavorText = (text) => text ? text.replace(/[\n\f\u00ad]/g, ' ') : '';
    const capitalize = (s) => s ? s.charAt(0).toUpperCase() + s.slice(1) : '';
    const formatName = (name) => name ? name.split('-').map(capitalize).join(' ') : '';
    const formatVersionName = (name) => name ? name.split('-').map(capitalize).join(' ') : ''; // Added back
    const getPokemonIdFromUrl = (url) => { if (!url) return null; const parts = url.split('/').filter(Boolean); const id = parts.pop(); return !isNaN(id) ? parseInt(id, 10) : null; };

    // --- View Switching ---
    function openDetailLightbox() {
        console.log("Attempting to open detail lightbox...");
        if (!detailViewLightbox) { console.error("Detail lightbox element not found!"); return; }
        detailViewLightbox.classList.remove('hidden');
        requestAnimationFrame(() => { detailViewLightbox.classList.add('visible'); });
        document.body.style.overflow = 'hidden';
        console.log("Detail lightbox should be visible now.");
    }
    function closeDetailLightbox() {
        if (!detailViewLightbox) return;
        detailViewLightbox.classList.remove('visible');
        const handleTransitionEnd = (event) => { if (event.target === detailViewLightbox && !detailViewLightbox.classList.contains('visible')) { detailViewLightbox.classList.add('hidden'); detailViewLightbox.removeEventListener('transitionend', handleTransitionEnd); } };
        detailViewLightbox.addEventListener('transitionend', handleTransitionEnd);
        setTimeout(() => { if (!detailViewLightbox.classList.contains('visible')) { detailViewLightbox.classList.add('hidden'); } }, 500);
        document.body.style.overflow = '';
    }

    // --- Fetch Functions ---
    async function fetchAllPokemonSpecies() { if (allPokemonSpeciesList) return allPokemonSpeciesList; console.log("Fetching all Pokémon species list..."); const range = GENERATION_RANGES.all; const url = `${POKEAPI_BASE_URL}/pokemon-species?limit=${range.limit}&offset=${range.offset}`; try { const response = await fetch(url); if (!response.ok) throw new Error('Failed to fetch all species'); const data = await response.json(); allPokemonSpeciesList = data.results.map(species => ({ name: species.name, id: getPokemonIdFromUrl(species.url), url: `${POKEAPI_BASE_URL}/pokemon/${getPokemonIdFromUrl(species.url)}` })).filter(p => p.id !== null).sort((a, b) => a.id - b.id); console.log(`Fetched ${allPokemonSpeciesList.length} species.`); return allPokemonSpeciesList; } catch (error) { console.error("Error fetching all species:", error); showDexGridError("Failed to load full Pokémon list."); return []; } }
    async function fetchGenerationList(genNumber) { if (genNumber === 'all') return await fetchAllPokemonSpecies(); if (fullPokemonListCache[genNumber]) return fullPokemonListCache[genNumber]; console.log(`Fetching list for Gen ${genNumber}`); const url = `${POKEAPI_BASE_URL}/generation/${genNumber}`; try { const response = await fetch(url); if (!response.ok) throw new Error(`Failed Gen ${genNumber}`); const data = await response.json(); const pokemonList = data.pokemon_species.map(species => ({ name: species.name, id: getPokemonIdFromUrl(species.url), url: `${POKEAPI_BASE_URL}/pokemon/${getPokemonIdFromUrl(species.url)}` })).filter(p => p.id !== null).sort((a, b) => a.id - b.id); fullPokemonListCache[genNumber] = pokemonList; return pokemonList; } catch (error) { console.error(`Error fetching Gen ${genNumber} list:`, error); showDexGridError(`Failed to load Gen ${genNumber}.`); return []; } }
    async function fetchTypeData(typeName) { if (typeDataCache[typeName]) return typeDataCache[typeName]; console.log(`Fetching Pokémon for type: ${typeName}`); const url = `${POKEAPI_BASE_URL}/type/${typeName}`; try { const response = await fetch(url); if (!response.ok) throw new Error(`Failed type ${typeName}`); const data = await response.json(); const pokemonList = data.pokemon.map(p => ({ name: p.pokemon.name, id: getPokemonIdFromUrl(p.pokemon.url), url: p.pokemon.url })).filter(p => p.id !== null).sort((a, b) => a.id - b.id); typeDataCache[typeName] = pokemonList; return pokemonList; } catch (error) { console.error(`Error fetching type ${typeName}:`, error); showDexGridError(`Failed to load type ${typeName}.`); return []; } }
    async function fetchDetailedPokemonData(identifier) { /* Reinstated variant/gender checks */ const cacheKey = String(identifier).toLowerCase(); if (detailedPokemonCache[cacheKey]) return detailedPokemonCache[cacheKey]; console.log(`Fetching detail for ${identifier}`); const pokemonUrl = `${POKEAPI_BASE_URL}/pokemon/${identifier}`; let speciesUrl = null; try { const tempRes = await fetch(pokemonUrl); if (!tempRes.ok) throw await handleFetchError(tempRes, identifier); const tempData = await tempRes.json(); speciesUrl = tempData.species.url; } catch (e) { console.warn("Could not determine species URL from name alone for variant fetching", e); throw e; } let speciesData = null; let varieties = []; try { const [pokemonRes, speciesRes] = await Promise.all([fetch(pokemonUrl), speciesUrl ? fetch(speciesUrl) : Promise.resolve(null)]); if (!pokemonRes.ok) throw await handleFetchError(pokemonRes, identifier); const pokemonData = await pokemonRes.json(); if (speciesRes && speciesRes.ok) { speciesData = await speciesRes.json(); varieties = speciesData.varieties?.map(v => ({ name: formatName(v.pokemon.name), url: v.pokemon.url, identifier: v.pokemon.name })) || []; } else if (speciesRes) { console.warn(`No species data for ${identifier}: ${speciesRes.statusText}`); } const hasVariants = varieties.length > 1; const hasGenderSprites = pokemonData.sprites.front_female !== null; const combinedData = { id: pokemonData.id, name: pokemonData.name, baseName: speciesData?.name || pokemonData.name, sprite: pokemonData.sprites.other?.home?.front_default || pokemonData.sprites.other?.['official-artwork']?.front_default || pokemonData.sprites.front_default || 'https://placehold.co/96x96/cccccc/ffffff?text=?', types: pokemonData.types.map(t => t.type.name), fullPokemonData: pokemonData, fullSpeciesData: speciesData, hasVariants: hasVariants, hasGenderSprites: hasGenderSprites, varieties: varieties }; detailedPokemonCache[cacheKey] = combinedData; return combinedData; } catch (error) { console.error(`Error fetching detailed data for ${identifier}:`, error); throw error; } }
    async function fetchTcgData(pokemonName) { /* Reinstated */ detailTcgLoader.classList.remove('hidden'); detailTcgErrorDiv.classList.add('hidden'); detailTcgCardsContainer.innerHTML = ''; currentTcgCards = []; if (TCG_API_KEY === 'YOUR_API_KEY' || !TCG_API_KEY) { showDetailTcgError("TCG API Key missing or invalid."); detailTcgLoader.classList.add('hidden'); return; } const query = `name:"${pokemonName}"`; const tcgUrl = `https://api.pokemontcg.io/v2/cards?q=${encodeURIComponent(query)}&orderBy=-set.releaseDate,number&pageSize=150`; try { const response = await fetch(tcgUrl, { headers: { 'X-Api-Key': TCG_API_KEY } }); if (!response.ok) throw await handleFetchError(response, `TCG cards for ${pokemonName}`); const tcgData = await response.json(); currentTcgCards = tcgData.data || []; filterAndDisplayTcgData(); detailTcgErrorDiv.classList.add('hidden'); } catch (error) { console.error("Error fetching TCG data:", error); currentTcgCards = []; filterAndDisplayTcgData(); showDetailTcgError(`TCG Fetch Error: ${error.message}`); } finally { detailTcgLoader.classList.add('hidden'); } }
    async function handleFetchError(response, resourceName = 'resource') { /* ... (same as before) ... */ if (response.status === 404) return new Error(`Data for "${resourceName}" not found (404).`); try { const errorData = await response.json(); return new Error(`API Error (${response.status}): ${errorData?.error?.message || response.statusText}`); } catch (e) { return new Error(`API Request Failed (${response.status}): ${response.statusText}`); } }

    // --- Dex Grid Display ---
    async function applyFiltersAndDisplayGrid() { /* ... (same as before) ... */ dexGridLoader.classList.remove('hidden'); pokedexGrid.innerHTML = ''; try { const baseList = await fetchGenerationList(currentGeneration); if (!baseList || baseList.length === 0) { showDexGridError(`No Pokémon found for Generation ${currentGeneration === 'all' ? 'All' : currentGeneration}.`); return; } let filteredList = baseList; if (currentTypeFilter !== 'all') { const typePokemonList = await fetchTypeData(currentTypeFilter); const typePokemonIds = new Set(typePokemonList.map(p => p.id)); filteredList = baseList.filter(p => typePokemonIds.has(p.id)); } if (filteredList.length === 0) { showDexGridError(`No ${capitalize(currentTypeFilter)} Pokémon found in Generation ${currentGeneration === 'all' ? 'All' : currentGeneration}.`); } else { displayDexGrid(filteredList); } } catch (error) { console.error("Error applying filters:", error); showDexGridError("An error occurred while filtering Pokémon."); } finally { dexGridLoader.classList.add('hidden'); } }
    async function displayDexGrid(pokemonList) { /* ... (same as before) ... */ pokedexGrid.innerHTML = ''; if (!pokemonList || pokemonList.length === 0) { return; } const fragment = document.createDocumentFragment(); const initialDetailPromises = pokemonList.slice(0, 15).map(p => fetchDetailedPokemonData(p.id).catch(e => null)); await Promise.allSettled(initialDetailPromises); pokemonList.forEach(pokemon => { const card = createDexGridCard(pokemon); fragment.appendChild(card); }); pokedexGrid.appendChild(fragment); }
    function createDexGridCard(pokemon) { /* Reinstated variant check */ const li = document.createElement('li'); li.className = 'pokedex-grid-card'; li.dataset.pokemonId = pokemon.id; li.dataset.pokemonName = pokemon.name; const cachedData = detailedPokemonCache[String(pokemon.id)] || detailedPokemonCache[pokemon.name]; const name = cachedData?.name ? capitalize(cachedData.name) : capitalize(pokemon.name); const id = cachedData?.id ? String(cachedData.id).padStart(3, '0') : String(pokemon.id).padStart(3, '0'); const image = cachedData?.sprite || 'https://placehold.co/96x96/cccccc/ffffff?text=?'; const types = cachedData?.types || []; const hasVariants = cachedData?.hasVariants || false; let color1 = 'var(--color-bg-panel)', color2 = 'var(--color-bg-light-panel)'; if (types.length === 1) { const typeName = types[0]; color1 = `var(--type-${typeName}, var(--color-secondary))`; color2 = `var(--type-${typeName}-light, var(--color-primary))`; } else if (types.length > 1) { const typeName1 = types[0]; const typeName2 = types[1]; color1 = `var(--type-${typeName1}, var(--color-secondary))`; color2 = `var(--type-${typeName2}, var(--color-primary))`; } li.style.setProperty('--card-gradient-color-1', color1); li.style.setProperty('--card-gradient-color-2', color2); const primaryType = types.length > 0 ? types[0] : 'normal'; li.style.setProperty('--dynamic-type-color', `var(--type-${primaryType}, var(--color-accent))`); li.innerHTML = `<div class="pokemon-card-header">${hasVariants ? '<span class="variant-indicator" title="Has Variants">✨</span>' : ''}<span class="pokemon-card-id">#${id}</span></div><div class="pokemon-card-img-container"><img src="${image}" alt="${name}" class="pokemon-card-image" loading="lazy" onerror="this.src='https://placehold.co/96x96/cccccc/ffffff?text=?'"></div><div class="pokemon-card-info"><h3 class="pokemon-card-name">${name}</h3><div class="pokemon-card-types">${types.map(type => `<span class="pokemon-card-type type-${type}">${type}</span>`).join('')}</div></div>`; li.addEventListener('click', () => { console.log(`Card click registered for: ${pokemon.name || pokemon.id}`); fetchAndDisplayDetailData(pokemon.name || pokemon.id); }); if (!cachedData) { fetchDetailedPokemonData(pokemon.id).then(data => { if (data) { li.querySelector('.pokemon-card-name').textContent = capitalize(data.name); li.querySelector('.pokemon-card-id').textContent = `#${String(data.id).padStart(3, '0')}`; li.querySelector('.pokemon-card-image').src = data.sprite; const typesHtml = data.types.map(type => `<span class="pokemon-card-type type-${type}">${type}</span>`).join(''); li.querySelector('.pokemon-card-types').innerHTML = typesHtml; const cardPrimaryType = data.types.length > 0 ? data.types[0] : 'normal'; let c1 = 'var(--color-bg-panel)', c2 = 'var(--color-bg-light-panel)'; if (data.types.length === 1) { c1 = `var(--type-${cardPrimaryType}, var(--color-secondary))`; c2 = `var(--type-${cardPrimaryType}-light, var(--color-primary))`; } else if (data.types.length > 1) { c1 = `var(--type-${data.types[0]}, var(--color-secondary))`; c2 = `var(--type-${data.types[1]}, var(--color-primary))`; } li.style.setProperty('--card-gradient-color-1', c1); li.style.setProperty('--card-gradient-color-2', c2); li.style.setProperty('--dynamic-type-color', `var(--type-${cardPrimaryType}, var(--color-accent))`); if (data.hasVariants) { const header = li.querySelector('.pokemon-card-header'); if (!header.querySelector('.variant-indicator')) header.insertAdjacentHTML('afterbegin', '<span class="variant-indicator" title="Has Variants">✨</span>'); } } }).catch(error => console.warn(`Failed card update: ${pokemon.name}`, error)); } return li; }

    // --- Detail View Display & Logic ---
    async function fetchAndDisplayDetailData(identifier) {
        openDetailLightbox(); // Open lightbox shell immediately
        detailLoader.classList.remove('hidden');
        detailPokemonInfoDiv.classList.add('hidden');
        detailErrorMessageDiv.classList.add('hidden');
        resetDetailUIState();

        try {
            console.log(`Fetching details for lightbox: ${identifier}`);
            const data = await fetchDetailedPokemonData(identifier);
            if (!data || !data.fullPokemonData) {
                throw new Error(`Could not retrieve full data for ${identifier}`);
            }
            console.log("Detailed data fetched:", data);
            currentPokemonData = data.fullPokemonData;
            currentSpeciesData = data.fullSpeciesData;
            currentVarieties = data.varieties || [];
            processAndDisplayDetailData(data); // Populate lightbox content
            fetchTcgData(data.baseName || data.name); // Fetch TCG cards for lightbox
        } catch (error) {
            console.error("Error fetching detail data:", error);
            showDetailError(error.message); // Show error inside the lightbox
        } finally {
            detailLoader.classList.add('hidden'); // Hide loader
        }
    }

    function processAndDisplayDetailData(detailedData) { /* Reinstated variant/gender logic */ if (!detailedData || !detailedData.fullPokemonData) { console.error("Invalid data passed to processAndDisplayDetailData"); showDetailError("Failed to process Pokémon data."); return; } currentPokemonData = detailedData.fullPokemonData; currentSpeciesData = detailedData.fullSpeciesData; isShiny = false; isFemale = false; detailShinyToggleButton.classList.remove('active'); detailGenderToggleButton.classList.add('hidden'); detailGenderToggleButton.classList.remove('active'); currentStats = currentPokemonData.stats.filter(si => statNameMapping[si.stat.name]).map(si => ({ name: si.stat.name, displayName: statNameMapping[si.stat.name], value: si.base_stat })); currentStatSort = 'default'; currentMoves = currentPokemonData.moves.flatMap(moveInfo => moveInfo.version_group_details.map(detail => ({ name: moveInfo.move.name.replace('-', ' '), level: detail.move_learn_method.name === 'level-up' ? detail.level_learned_at : null }))).filter(move => move.level !== null && move.level > 0).sort((a, b) => a.level - b.level || a.name.localeCompare(b.name)).filter((move, index, self) => index === self.findIndex((m) => (m.name === move.name && m.level === move.level))); /* Removed slice */ currentFlavorTextEntries = []; if (currentSpeciesData?.flavor_text_entries) { const seenVersions = new Set(); currentFlavorTextEntries = currentSpeciesData.flavor_text_entries.filter(entry => entry.language.name === 'en').map(entry => ({ version: formatVersionName(entry.version.name), text: cleanFlavorText(entry.flavor_text) })).filter(entry => { if (!seenVersions.has(entry.version)) { seenVersions.add(entry.version); return true; } return false; }).sort((a, b) => a.version.localeCompare(b.version)); } populateVariantSelector(detailedData.varieties || [], currentPokemonData.name); detailVariantSelectorContainer.classList.toggle('hidden', !detailedData.hasVariants); updateDetailVisualSection(detailedData.hasGenderSprites); updateDetailGameInfoTab(detailedData.hasVariants); detailPokemonInfoDiv.classList.remove('hidden'); detailErrorMessageDiv.classList.add('hidden'); switchTab(detailMainTabsContainer.querySelector('.tab-button.active') || detailMainTabButtons[0]); switchSubTab(detailGameInfoTabsContainer.querySelector('.sub-tab-button.active') || detailSubTabButtons[0]); }
    function populateVariantSelector(varieties, currentFormIdentifier) { /* Reinstated */ detailVariantSelect.innerHTML = ''; if (!varieties || varieties.length <= 1) { detailVariantSelectorContainer.classList.add('hidden'); return; } varieties.forEach(variant => { const option = document.createElement('option'); option.value = variant.identifier; option.textContent = variant.name; if (variant.identifier === currentFormIdentifier) { option.selected = true; } detailVariantSelect.appendChild(option); }); detailVariantSelectorContainer.classList.remove('hidden'); }
    function updateDetailVisualSection(hasGenderSprites) { /* Reinstated gender toggle logic */ if (!currentPokemonData) return; const types = currentPokemonData.types; let color1 = 'var(--color-secondary)'; let color2 = 'var(--color-primary)'; if (types.length === 1) { const typeName = types[0].type.name; color1 = `var(--type-${typeName}, var(--color-secondary))`; color2 = `var(--type-${typeName}-light, var(--color-primary))`; } else if (types.length > 1) { const typeName1 = types[0].type.name; const typeName2 = types[1].type.name; color1 = `var(--type-${typeName1}, var(--color-secondary))`; color2 = `var(--type-${typeName2}, var(--color-primary))`; } document.documentElement.style.setProperty('--gradient-color-1', color1); document.documentElement.style.setProperty('--gradient-color-2', color2); document.documentElement.style.setProperty('--dynamic-type-color', color1); document.documentElement.style.setProperty('--dynamic-type-color-light', color2); updateActiveTabColor(); updateActiveSubTabColor(); updateStatSortButtons(); detailGenderToggleButton.classList.toggle('hidden', !hasGenderSprites); updatePokemonImage(); detailPokemonTypesDiv.innerHTML = ''; types.forEach(typeInfo => { const typeName = typeInfo.type.name; const typeColor = `var(--type-${typeName}, var(--color-text-secondary))`; const typeBadge = document.createElement('span'); typeBadge.className = 'type-badge'; typeBadge.textContent = typeName; typeBadge.style.backgroundColor = typeColor; detailPokemonTypesDiv.appendChild(typeBadge); }); }
    function updateDetailGameInfoTab(hasVariants) { /* Reinstated variant info logic */ if (!currentPokemonData) return; detailPokemonNameDisplay.textContent = formatName(currentPokemonData.name); detailPokemonIdSpan.textContent = `#${currentPokemonData.id.toString().padStart(3, '0')}`; detailPokemonHeightP.textContent = `${currentPokemonData.height / 10} m`; detailPokemonWeightP.textContent = `${currentPokemonData.weight / 10} kg`; detailVariantInfoSection.classList.toggle('hidden', !hasVariants); populateVersionSelector(); updateDescription(); renderActiveSubTabContent(); }
    function populateVersionSelector() { /* ... (same as before) ... */ detailGameVersionSelect.innerHTML = ''; if (currentFlavorTextEntries.length > 0) { currentFlavorTextEntries.forEach((entry, index) => { const option = document.createElement('option'); option.value = index; option.textContent = entry.version; detailGameVersionSelect.appendChild(option); }); detailGameVersionSelect.disabled = false; } else { const option = document.createElement('option'); option.textContent = 'No entries'; detailGameVersionSelect.appendChild(option); detailGameVersionSelect.disabled = true; } }
    function updateDescription() { /* ... (same as before) ... */ const selectedIndex = detailGameVersionSelect.value; if (selectedIndex !== null && currentFlavorTextEntries[selectedIndex]) { detailPokemonDescriptionP.textContent = currentFlavorTextEntries[selectedIndex].text; } else if (currentFlavorTextEntries.length > 0) { detailPokemonDescriptionP.textContent = currentFlavorTextEntries[0].text; detailGameVersionSelect.value = 0; } else { detailPokemonDescriptionP.textContent = 'No description available.'; } }
    function renderStats() { /* ... (same as before) ... */ detailStatsContainer.innerHTML = ''; let statsToRender = [...currentStats]; switch (currentStatSort) { case 'name': statsToRender.sort((a, b) => a.displayName.localeCompare(b.displayName)); break; case 'asc': statsToRender.sort((a, b) => a.value - b.value); break; case 'desc': statsToRender.sort((a, b) => b.value - a.value); break; case 'default': statsToRender.sort((a, b) => defaultStatOrder.indexOf(a.name) - defaultStatOrder.indexOf(b.name)); break; } const statColor = getComputedStyle(document.documentElement).getPropertyValue('--dynamic-type-color').trim() || 'var(--color-accent)'; statsToRender.forEach(stat => { const statMax = 255; const statPercentage = Math.max(1, (stat.value / statMax) * 100); const statElement = document.createElement('div'); statElement.className = 'flex items-center w-full'; statElement.innerHTML = `<span class="text-xs font-medium text-[var(--color-text-secondary)] w-1/4">${stat.displayName}</span><span class="text-sm font-bold text-[var(--color-text-primary)] w-[50px] text-right mr-2">${stat.value}</span><div class="stat-bar-bg flex-grow h-2.5 rounded-full"><div class="stat-bar h-2.5 rounded-full" style="width: 0%; background-color: ${statColor};"></div></div>`; detailStatsContainer.appendChild(statElement); setTimeout(() => { const bar = statElement.querySelector('.stat-bar'); if(bar) bar.style.width = `${statPercentage}%`; }, 50); }); }
    function renderAbilities() { /* ... (same as before) ... */ detailAbilitiesList.innerHTML = ''; if (currentPokemonData.abilities.length > 0) { currentPokemonData.abilities.forEach(abilityInfo => { const abilityItem = document.createElement('li'); abilityItem.textContent = abilityInfo.ability.name.replace('-', ' '); if (abilityInfo.is_hidden) abilityItem.innerHTML += ' <span class="italic">(Hidden)</span>'; detailAbilitiesList.appendChild(abilityItem); }); } else { detailAbilitiesList.innerHTML = '<li class="italic text-[var(--color-text-secondary)]">No abilities listed.</li>'; } }
    function renderMoves() { /* ... (same as before) ... */ detailMovesList.innerHTML = ''; if (!currentMoves || currentMoves.length === 0) { detailMovesList.innerHTML = '<li class="italic text-[var(--color-text-secondary)]">No level-up moves found.</li>'; if (detailMovesPagination) detailMovesPagination.classList.add('hidden'); return; } const totalPages = Math.ceil(currentMoves.length / movesPerPage); currentMovesPage = Math.max(1, Math.min(currentMovesPage, totalPages)); const startIndex = (currentMovesPage - 1) * movesPerPage; const endIndex = startIndex + movesPerPage; const movesToDisplay = currentMoves.slice(startIndex, endIndex); movesToDisplay.forEach(move => { const moveItem = document.createElement('li'); moveItem.textContent = `Lv ${move.level}: ${move.name}`; detailMovesList.appendChild(moveItem); }); if (detailMovesPagination) { if (totalPages > 1) { if (detailPrevMovePageButton) detailPrevMovePageButton.disabled = currentMovesPage === 1; if (detailNextMovePageButton) detailNextMovePageButton.disabled = currentMovesPage === totalPages; if (detailMovePageInfo) detailMovePageInfo.textContent = `Page ${currentMovesPage} of ${totalPages}`; detailMovesPagination.classList.remove('hidden'); } else { detailMovesPagination.classList.add('hidden'); } } }
    function renderActiveSubTabContent() { /* ... (same as before) ... */ switch(activeSubTab) { case 'stats-content': renderStats(); hideMovesPagination(); break; case 'abilities-content': renderAbilities(); hideMovesPagination(); break; case 'moves-content': currentMovesPage = 1; renderMoves(); break; case 'summary-content': default: hideMovesPagination(); break; } }
    function hideMovesPagination() { if (detailMovesPagination) detailMovesPagination.classList.add('hidden'); }

    // --- TCG Display & Filtering (Detail View) ---
    function filterAndDisplayTcgData() { /* ... (same as before) ... */ const searchTerm = detailTcgSearchInput.value.toLowerCase().trim(); if (searchTerm) { filteredTcgCards = currentTcgCards.filter(card => card.name.toLowerCase().includes(searchTerm) || card.attacks?.some(attack => attack.name.toLowerCase().includes(searchTerm) || attack.text?.toLowerCase().includes(searchTerm)) || card.abilities?.some(ability => ability.name.toLowerCase().includes(searchTerm) || ability.text?.toLowerCase().includes(searchTerm))); } else { filteredTcgCards = [...currentTcgCards]; } displayTcgData(filteredTcgCards); }
    function displayTcgData(cards) { /* ... (same as before) ... */ detailTcgCardsContainer.innerHTML = ''; if (!cards || cards.length === 0) { const message = detailTcgSearchInput.value.trim() ? 'No cards match your filter.' : 'No TCG cards found for this Pokémon.'; detailTcgCardsContainer.innerHTML = `<p class="text-center text-[var(--color-text-secondary)] italic p-4">${message}</p>`; return; } const groupedBySet = cards.reduce((acc, card) => { const setName = card.set?.name || 'Unknown Set'; if (!acc[setName]) acc[setName] = { details: card.set, cards: [] }; acc[setName].cards.push(card); return acc; }, {}); const sortedSetNames = Object.keys(groupedBySet).sort((a, b) => { const dateA = groupedBySet[a].details?.releaseDate; const dateB = groupedBySet[b].details?.releaseDate; if (dateA && dateB) return new Date(dateB) - new Date(dateA); return a.localeCompare(b); }); sortedSetNames.forEach(setName => { const setGroup = groupedBySet[setName]; const setGroupElement = document.createElement('div'); setGroupElement.className = 'tcg-set-group'; const setHeader = document.createElement('div'); setHeader.className = 'tcg-set-header'; setHeader.innerHTML = `<span>${setName} (${setGroup.details?.series || 'N/A'})</span><i class="fas fa-chevron-down"></i>`; setHeader.addEventListener('click', () => toggleSetCollapse(setHeader)); const setContent = document.createElement('div'); setContent.className = 'tcg-set-content'; setGroup.cards.forEach(card => { const cardElement = createTcgCardElement(card); setContent.appendChild(cardElement); }); setGroupElement.appendChild(setHeader); setGroupElement.appendChild(setContent); detailTcgCardsContainer.appendChild(setGroupElement); }); }
    function createTcgCardElement(card) { /* ... (same as before) ... */ const cardElement = document.createElement('div'); cardElement.className = 'tcg-card'; cardElement.dataset.cardId = card.id; cardElement.addEventListener('click', () => openTcgLightbox(card.id)); const imageElement = document.createElement('img'); imageElement.src = card.images?.small || 'https://placehold.co/100x140/cccccc/ffffff?text=No+Img'; imageElement.alt = `Image of ${card.name} TCG card`; imageElement.className = 'tcg-card-image'; imageElement.loading = 'lazy'; imageElement.onerror = () => { imageElement.src = 'https://placehold.co/100x140/cccccc/ffffff?text=No+Img'; }; const detailsElement = document.createElement('div'); detailsElement.className = 'tcg-card-details'; detailsElement.innerHTML = `<h5>${card.name} <span class="text-xs font-normal text-[var(--color-text-secondary)]">(${card.id})</span></h5>`; cardElement.appendChild(imageElement); cardElement.appendChild(detailsElement); return cardElement; }
    function toggleSetCollapse(headerElement) { /* ... (same as before) ... */ const contentElement = headerElement.nextElementSibling; const iconElement = headerElement.querySelector('i'); const isCollapsed = headerElement.classList.toggle('collapsed'); contentElement.classList.toggle('hidden', isCollapsed); iconElement.classList.toggle('fa-chevron-down', !isCollapsed); iconElement.classList.toggle('fa-chevron-right', isCollapsed); }

    // --- TCG Lightbox Functions ---
    function openTcgLightbox(cardId) { /* ... (same as before) ... */ const card = currentTcgCards.find(c => c.id === cardId); if (!card) return; lightboxCardName.textContent = card.name; lightboxCardImage.src = card.images?.large || card.images?.small || 'https://placehold.co/300x420/cccccc/ffffff?text=No+Large+Img'; lightboxCardImage.alt = `Large image of ${card.name}`; lightboxCardImage.onerror = () => { lightboxCardImage.src = 'https://placehold.co/300x420/cccccc/ffffff?text=No+Large+Img'; }
        let detailsHtml = `<p><strong>Set:</strong> ${card.set?.name || 'N/A'} (${card.set?.series || 'N/A'})</p>`; if (card.hp) detailsHtml += `<p><strong>HP:</strong> ${card.hp}</p>`; if (card.types?.length) detailsHtml += `<p><strong>Type(s):</strong> ${card.types.join(', ')}</p>`; if (card.rarity) detailsHtml += `<p><strong>Rarity:</strong> ${card.rarity}</p>`;
        if (card.attacks?.length) { detailsHtml += `<h4 class="lightbox-detail-title">Attacks</h4>`; card.attacks.forEach(attack => { let costHtml = attack.cost?.map(type => `<span class="tcg-cost-icon tcg-type-${type}" title="${type}"></span>`).join('') || '(No Cost)'; detailsHtml += `<div class="lightbox-attack"><p><strong>${attack.name}</strong> ${costHtml} ${attack.damage ? `<span class="float-right font-bold">${attack.damage}</span>` : ''}</p>${attack.text ? `<p class="text-xs text-[var(--color-text-secondary)] mt-1">${attack.text}</p>` : ''}</div>`; }); }
        if (card.abilities?.length) { detailsHtml += `<h4 class="lightbox-detail-title">Abilities</h4>`; card.abilities.forEach(ability => { detailsHtml += `<div class="lightbox-ability"><p><strong>${ability.name}</strong> (${ability.type})</p>${ability.text ? `<p class="text-xs text-[var(--color-text-secondary)] mt-1">${ability.text}</p>` : ''}</div>`; }); }
        detailsHtml += `<h4 class="lightbox-detail-title">Combat Info</h4><div class="grid grid-cols-3 gap-2 text-xs">`; detailsHtml += `<div><strong>Weakness:</strong> ${card.weaknesses ? card.weaknesses.map(w => `${w.type} ${w.value}`).join(', ') : 'None'}</div>`; detailsHtml += `<div><strong>Resistance:</strong> ${card.resistances ? card.resistances.map(r => `${r.type} ${r.value}`).join(', ') : 'None'}</div>`; detailsHtml += `<div><strong>Retreat:</strong> ${card.retreatCost ? card.retreatCost.join(', ') : '0'}</div></div>`;
        lightboxCardDetails.innerHTML = detailsHtml; tcgLightbox.classList.add('visible'); document.body.style.overflow = 'hidden';
    }
    function closeTcgLightbox() { /* ... (same as before) ... */ tcgLightbox.classList.remove('visible'); document.body.style.overflow = ''; lightboxCardImage.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"; lightboxCardDetails.innerHTML = '<p>Loading details...</p>'; }

    // --- UI Update & Interaction (Detail View) ---
    function updatePokemonImage() { /* Reinstated gender logic */ if (!currentPokemonData) return; const sprites = currentPokemonData.sprites; const artwork = sprites.other?.['official-artwork']; const home = sprites.other?.home; let defaultSprite = artwork?.front_default || home?.front_default || sprites.front_default; let shinySprite = artwork?.front_shiny || home?.front_shiny || sprites.front_shiny; let femaleSprite = artwork?.front_female || home?.front_female || sprites.front_female; let shinyFemaleSprite = artwork?.front_shiny_female || home?.front_shiny_female || sprites.front_shiny_female; let targetUrl = defaultSprite; if (isShiny && isFemale && shinyFemaleSprite) { targetUrl = shinyFemaleSprite; } else if (isShiny && !isFemale && shinySprite) { targetUrl = shinySprite; } else if (!isShiny && isFemale && femaleSprite) { targetUrl = femaleSprite; } else if (isShiny && shinySprite) { targetUrl = shinySprite; } else if (isFemale && femaleSprite) { targetUrl = femaleSprite; } const placeholderUrl = 'https://placehold.co/256x256/cccccc/ffffff?text=?'; detailPokemonImage.src = targetUrl || placeholderUrl; detailPokemonImage.alt = `Image of ${isShiny ? 'shiny ' : ''}${isFemale ? 'female ' : ''}${currentPokemonData.name}`; detailPokemonImage.onerror = () => { detailPokemonImage.src = placeholderUrl; detailPokemonImage.alt = `${currentPokemonData.name} image not found`; }; }
    function toggleShiny() { /* ... (same as before) ... */ if (!currentPokemonData) return; isShiny = !isShiny; detailShinyToggleButton.classList.toggle('active', isShiny); updatePokemonImage(); }
    function toggleGender() { /* Reinstated */ if (!currentPokemonData || !currentPokemonData.sprites.front_female) return; isFemale = !isFemale; detailGenderToggleButton.classList.toggle('active', isFemale); updatePokemonImage(); }
    function updateStatSortButtons() { /* ... (same as before) ... */ const activeColor = getComputedStyle(document.documentElement).getPropertyValue('--dynamic-type-color').trim() || 'var(--color-secondary)'; detailStatSortButtonsContainer.querySelectorAll('.sort-button').forEach(button => { const isActive = button.dataset.sort === currentStatSort; button.classList.toggle('active', isActive); button.style.backgroundColor = isActive ? activeColor : ''; button.style.borderColor = isActive ? 'transparent' : ''; button.style.color = isActive ? 'white' : ''; }); }
    function resetDetailUIState() { /* Reinstated gender/variant resets */ detailGameVersionSelect.innerHTML = '<option>Loading...</option>'; detailGameVersionSelect.disabled = true; detailPokemonDescriptionP.textContent = 'Loading...'; /* Removed TCG resets */ detailStatsContainer.innerHTML = ''; currentStatSort = 'default'; updateStatSortButtons(); detailAbilitiesList.innerHTML = ''; detailMovesList.innerHTML = ''; isShiny = false; isFemale = false; detailShinyToggleButton.classList.remove('active'); detailGenderToggleButton.classList.add('hidden'); detailGenderToggleButton.classList.remove('active'); detailVariantSelectorContainer.classList.add('hidden'); detailVariantSelect.innerHTML = ''; switchSubTab(detailGameInfoTabsContainer.querySelector('[data-subtab="summary-content"]')); hideMovesPagination(); }
    function showDetailError(message) { /* ... (same as before) ... */ detailErrorText.textContent = message; detailErrorMessageDiv.classList.remove('hidden'); detailPokemonInfoDiv.classList.add('hidden'); detailLoader.classList.add('hidden'); }
    function showDexGridError(message) { /* ... (same as before) ... */ pokedexGrid.innerHTML = `<p class="text-center text-[var(--color-error)] p-4">${message}</p>`; dexGridLoader.classList.add('hidden'); }
    function switchTab(clickedTab) { /* Reinstated TCG tab logic */ if (!clickedTab) return; const targetTabId = clickedTab.dataset.tab; detailMainTabButtons.forEach(button => button.classList.remove('active')); clickedTab.classList.add('active'); updateActiveTabColor(); detailMainTabContents.forEach(content => content.classList.toggle('active', content.id === targetTabId)); }
    function switchSubTab(clickedSubTab) { /* ... (same as before) ... */ if (!clickedSubTab) return; const targetSubTabId = clickedSubTab.dataset.subtab; detailSubTabButtons.forEach(button => button.classList.remove('active')); clickedSubTab.classList.add('active'); activeSubTab = targetSubTabId; updateActiveSubTabColor(); detailSubTabContents.forEach(content => content.classList.toggle('active', content.id === targetSubTabId)); renderActiveSubTabContent(); }
    function updateActiveTabColor() { /* Reinstated TCG tab logic */ const activeTab = detailMainTabsContainer.querySelector('.tab-button.active'); const darkColor = getComputedStyle(document.documentElement).getPropertyValue('--dynamic-type-color').trim() || 'var(--color-secondary)'; const lightColor = getComputedStyle(document.documentElement).getPropertyValue('--dynamic-type-color-light').trim() || 'var(--color-primary)'; if (activeTab) { activeTab.style.backgroundColor = darkColor; activeTab.style.borderColor = lightColor; activeTab.style.color = 'white'; } detailMainTabButtons.forEach(button => { if (!button.classList.contains('active')) { button.style.backgroundColor = ''; button.style.borderColor = 'transparent'; button.style.color = ''; } }); }
    function updateActiveSubTabColor() { /* ... (same as before) ... */ const activeSubTab = detailGameInfoTabsContainer.querySelector('.sub-tab-button.active'); const darkColor = getComputedStyle(document.documentElement).getPropertyValue('--dynamic-type-color').trim() || 'var(--color-secondary)'; if (activeSubTab) { activeSubTab.style.backgroundColor = darkColor; activeSubTab.style.borderColor = 'transparent'; activeSubTab.style.color = 'white'; } detailSubTabButtons.forEach(button => { if (!button.classList.contains('active')) { button.style.backgroundColor = ''; button.style.borderColor = ''; button.style.color = ''; } }); }

    // --- Event Listeners ---
    mainSearchButton.addEventListener('click', () => { const searchTerm = mainSearchInput.value; if (searchTerm.trim()) fetchAndDisplayDetailData(searchTerm); });
    mainSearchInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') { const searchTerm = mainSearchInput.value; if (searchTerm.trim()) fetchAndDisplayDetailData(searchTerm); } });
    detailCloseButton.addEventListener('click', closeDetailLightbox);
    detailViewLightbox.addEventListener('click', (event) => { if (event.target === detailViewLightbox) closeDetailLightbox(); });
    generationTabsContainer.addEventListener('click', async (event) => { const button = event.target.closest('.gen-tab-button'); if (button && !button.classList.contains('active')) { generationTabsContainer.querySelectorAll('.gen-tab-button').forEach(btn => btn.classList.remove('active')); button.classList.add('active'); currentGeneration = button.dataset.generation === 'all' ? 'all' : parseInt(button.dataset.generation, 10); currentTypeFilter = 'all'; updateActiveTypeButton(); await applyFiltersAndDisplayGrid(); } });
    typeFilterButtonsContainer.addEventListener('click', async (event) => { const button = event.target.closest('.type-filter-button'); if (button && !button.classList.contains('active')) { typeFilterButtonsContainer.querySelectorAll('.type-filter-button').forEach(btn => btn.classList.remove('active')); button.classList.add('active'); currentTypeFilter = button.dataset.type; await applyFiltersAndDisplayGrid(); } });
    // Detail View Listeners
    detailMainTabsContainer.addEventListener('click', (event) => { if (event.target.classList.contains('tab-button')) switchTab(event.target); });
    detailGameInfoTabsContainer.addEventListener('click', (event) => { if (event.target.classList.contains('sub-tab-button')) switchSubTab(event.target); });
    detailShinyToggleButton.addEventListener('click', toggleShiny);
    detailGenderToggleButton.addEventListener('click', toggleGender); // Reinstated listener
    detailGameVersionSelect.addEventListener('change', updateDescription);
    detailVariantSelect.addEventListener('change', (event) => { const selectedVariantIdentifier = event.target.value; if(selectedVariantIdentifier && currentPokemonData?.name !== selectedVariantIdentifier) { fetchAndDisplayDetailData(selectedVariantIdentifier); } }); // Reinstated listener
    detailStatSortButtonsContainer.addEventListener('click', (event) => { if (event.target.classList.contains('sort-button')) { const sortType = event.target.dataset.sort; currentStatSort = (currentStatSort === sortType && sortType !== 'default') ? 'default' : sortType; renderStats(); updateStatSortButtons(); } });
    detailTcgSearchButton.addEventListener('click', filterAndDisplayTcgData); // Reinstated
    detailTcgSearchInput.addEventListener('input', filterAndDisplayTcgData); // Reinstated
    detailTcgSearchInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') event.preventDefault(); }); // Reinstated
    lightboxCloseButton.addEventListener('click', closeTcgLightbox); // TCG Lightbox close - Reinstated
    tcgLightbox.addEventListener('click', (event) => { if (event.target === tcgLightbox) closeTcgLightbox(); }); // TCG overlay click - Reinstated
    // Moves Pagination Listeners
    if(detailPrevMovePageButton) detailPrevMovePageButton.addEventListener('click', () => { if (currentMovesPage > 1) { currentMovesPage--; renderMoves(); } });
    if(detailNextMovePageButton) detailNextMovePageButton.addEventListener('click', () => { const totalPages = Math.ceil(currentMoves.length / movesPerPage); if (currentMovesPage < totalPages) { currentMovesPage++; renderMoves(); } });
    // Grid click listener (using event delegation)
    pokedexGrid.addEventListener('click', (event) => {
        const card = event.target.closest('.pokedex-grid-card');
        if (card) {
            const pokemonIdentifier = card.dataset.pokemonName || card.dataset.pokemonId;
            if (pokemonIdentifier) {
                console.log(`Card click registered for: ${pokemonIdentifier}`);
                fetchAndDisplayDetailData(pokemonIdentifier); // Trigger lightbox fetch/display
            } else {
                console.error("Could not find identifier on clicked card:", card);
            }
        }
    });

    // --- Initialization ---
    function populateGenerationTabs() { /* ... (same as before) ... */ generationTabsContainer.innerHTML = ''; const allButton = document.createElement('button'); allButton.className = 'gen-tab-button'; allButton.dataset.generation = 'all'; allButton.textContent = `All`; generationTabsContainer.appendChild(allButton); Object.keys(GENERATION_RANGES).forEach(genNum => { if (genNum === 'all') return; const button = document.createElement('button'); button.className = 'gen-tab-button'; button.dataset.generation = genNum; button.textContent = `Gen ${genNum}`; if (parseInt(genNum, 10) === currentGeneration) button.classList.add('active'); generationTabsContainer.appendChild(button); }); }
    function populateTypeFilters() { /* ... (same as before) ... */ typeFilterButtonsContainer.innerHTML = ''; const allButton = document.createElement('button'); allButton.className = 'type-filter-button active'; allButton.dataset.type = 'all'; allButton.textContent = 'All'; typeFilterButtonsContainer.appendChild(allButton); POKEMON_TYPES.forEach(type => { const button = document.createElement('button'); button.className = 'type-filter-button'; button.dataset.type = type; button.textContent = type; button.style.setProperty('--dynamic-type-color', `var(--type-${type})`); button.classList.add(`type-bg-${type}`); typeFilterButtonsContainer.appendChild(button); }); }
    function updateActiveTypeButton() { /* ... (same as before) ... */ typeFilterButtonsContainer.querySelectorAll('.type-filter-button').forEach(btn => { btn.classList.toggle('active', btn.dataset.type === currentTypeFilter); }); }

    async function initializeApp() {
        console.log("Initializing Pokedex App...");
        populateGenerationTabs(); populateTypeFilters();
        dexGridLoader.classList.remove('hidden');
        try { const initialList = await fetchGenerationList(currentGeneration); displayDexGrid(initialList); } catch (error) { /* Handled */ }
        finally { dexGridLoader.classList.add('hidden'); setTimeout(() => { initialLoadingOverlay.classList.add('loaded'); appContainer.classList.remove('hidden'); }, 500); }
        console.log("Pokedex App Initialized.");
    }

    initializeApp(); // Start the app

}); // End DOMContentLoaded Listener
